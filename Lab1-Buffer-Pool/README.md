# 实验一：缓冲池

在存储管理器中实现缓冲池。缓冲池负责将物理页面从主存储器来回移动到磁盘。

它允许DBMS支持大于系统可用内存量的数据库。它的操作对系统中的其他部分是透明的。

例如，系统使用其唯一标识符（page_id）向缓冲池请求页面，并且它不知道该页面是否已经在内存中，或者系统是否必须从磁盘检索它。

你的实现需要是线程安全的。多个线程将同时访问内部数据结构，因此您需要确保其关键部分受锁存器保护（这些在操作系统中称为“锁”）。

需要在存储管理器中实现以下三个组件：
1. 可扩展的哈希表
2. LRU页面替换政策
3. 缓冲池管理器


## 可扩展的哈希表
### 简介
可扩展哈希表是一种动态哈希表，也就是说，它的桶的个数是可以增加的

### 特性
1. 相比较静态哈希表，桶不再是数据块本身，而是用一个指向块的指针数组来表示桶
2. 指针数组能增长，它的长度总是2的幂，因此数组每增长一次，桶的数目就翻倍
3. 不过并非每个桶都有一个数据块，如果某些桶中的所有记录可以放在一个块中，那么这些桶可以共享一个块
4. 哈希函数h为每个键计算出一个K位二进制序列，该K足够大，比如32。但是桶的数目总是使用从序列第一位或者最后一位算起的若干位，此位数小于K，比如说i位。也就是说，当i是使用的位数时，桶数组将有2的i次方个项


### 实验中的难点
1. 要理解全局的`depth`和局部(桶)的`depth`的作用，用`HashKey`找位置时要仔细
2. 实验中最难的操作就是插入了，因为要考虑到当某个桶里的数据满的时候，就要分裂，即增加局部的`depth`，然后重新分配桶的`map`，分裂后桶的数目要加倍，全局的`depth`要一直大于等于局部的`depth`


## LRU页面替换政策
### 简介
内存管理的一种页面置换算法，对于在内存中但又不用的数据块（内存块）叫做LRU，操作系统会根据哪些数据属于LRU而将其移出内存而腾出空间来加载另外的数据。

LRU是Least Recently Used的缩写，即最近最少使用，常用于页面置换算法，是为虚拟页式存储管理服务的。

### 实验中的难点
1. 要选好数据结构，我选择的数据结构是哈希表，即STL中的`unordered_map`，键是页面，值是一个节点，节点我用一个双向链表连接起来
2. 剩下的工作就很简单了

### Q&A
#### 为什么要用哈希表？
虽然说实现LRU算法虽简单的数据结构是队列，但当你插入一个页面时，如果该页面是之前就已经在队列中的，那么就要找出之前已经存在队列中的那个页面，然后删除，在重新插入在队列尾部，找到并删除这个操作对于队列来说明显不合适，哈希表能快速查找并删除

#### 为什么节点要用双向链表连接？
既然已经决定了要用双向链表，那么怎么知道那个页面是最近未使用呢？那必定要用一个类似队列的东西，选择链表最为合适，然后为什么要用双向呢？是由于实验要求要支持`Erase`操作，即指定某个页面并删除，虽然用单向链表能找到要删除的页面，但是要删除一条链表中的某个节点，必须要知道前后的节点才能删除，因此要保存指向前一个节点的指针
