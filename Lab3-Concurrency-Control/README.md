# 实验三：并发控制

## 任务一：Lock Manager
为了确保正确交叉事务的操作，DBMS将使用锁管理器（LM）来控制何时允许事务访问数据项。

LM的基本思想是它维护一个关于活动事务当前持有的锁的内部数据结构。

然后，事务在允许访问数据项之前向LM发出锁定请求。LM将授予对调用事务的锁定，阻止该事务或中止它。

此任务要求您实现支持两阶段锁定（2PL）和严格两阶段锁定（S2PL）的元组级LM 。

## 知识笔记
### Two-phase locking - 2PL
简单来说就是，一个事务分为两个阶段，上升阶段(获取锁)和下降阶段(释放锁)，在上升阶段不能释放锁，在下降阶段不能获得锁。

这样就保证了冲突可串行化，但是不能保证不会发生死锁，所以我门采用下面的方法来预防死锁。

### Strict Two-phase locking - S2PL
在2PL的基础上，还要求事务持有的所有排他锁必须在事务提交后方可释放。

这个要求保证未提交事务所写的任何数据在该事务提交之前均以排它锁方式加锁，防止其他事务读这些数据。

### wait-die
Lock Manager 将实施WAIT-DIE策略以预防死锁
+ 该方案是基于非剥夺方法。当进程Pi请求的资源正被进程Pj占有时，只有当Pi的时间戳比进程Pj的时间戳小时，
即Pi比Pj老时，Pi才能等待。否则Pi被卷回（roll-back），即死亡。
+ 一个进程死亡后会释放他所占用的所有资源。在这里假定死亡的进程将带着同样的时间戳重新运行。
+ 由于具有较小时间戳的进程才等待具有较大时间戳的进程，因此很显然死锁不会发生。当进程在等待特定的资源时，不会释放资源。
+ 一旦一个进程释放一个资源，与这个资源相联系的等待队列中的一个进程将被激活。


### Lock Manager
锁管理器可以实现为一个过程，它从事务接受消息并反馈消息。锁管理器过程针对锁请求消息返回授予锁消息，或者要求事务回滚的消息。
解锁消息只需要得到一个确认回答，但可能引发为其他等待事务的授予锁消息。

锁管理器为目前已加锁的每个数据项维护一个链表，每一个请求为链表中一条记录，按请求到达的顺序排序。

它使用一个以数据项名称为索引的散列表来查找链表中的数据项，叫锁表。

![](https://github.com/liu-jianhao/CMU-15-445/blob/master/Lab3-Concurrency-Control/%E9%94%81%E8%A1%A8.png)

上图包含五个不同数据项的锁。已授予锁的事务用深色阴影方块表示，等待授予锁的事务用浅色方块。

除了图上看到的，锁表还应当维护一个基于事务表示符的索引，这样它可以有效地确定给定事务持有的锁集。


锁管理器处理请求：
+ 当一条请求消息到达时，如果相应数据项的链表存在，在该链表末尾增加一个记录；否则，新建一个包含该请求记录的链表。
+ 收到一个事务的解锁消息是，它将与该事务相对应的数据项链表中的记录删除，然后检查随后的记录，如果有，检查该请求能否被授权
+ 如果一个事务中止，锁管理器删除该事务产生的正在等待加锁的所有请求。
这个算法保证了锁请求无饿死现象，因为在先前接受到的请求正在等待加锁时，后来者不可能获得授权。

## 任务一调试
任务一还算比较简单，主要先将锁表的数据结构想好，之后的操作基本上就水到渠成了，但毕竟是多线程的并发，难免会有问题。
```
$ test/lock_manager_test
Running main() from gmock_main.cc
[==========] Running 9 tests from 1 test case.
[----------] Global test environment set-up.
[----------] 9 tests from LockManagerTest
[ RUN      ] LockManagerTest.BasicTest
^C
```
测试程序卡住了，运行不下去，难道是有死锁？？


## 任务二：并发索引
